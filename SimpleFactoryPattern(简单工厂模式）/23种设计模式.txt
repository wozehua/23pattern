设计模式分为三类
创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
结构型模式：共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式：共十一种：策略模式、模版方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、
状态模式、访问者模式 、中介者模式、解释器模式。
其实还有两类：并发型模式和线程池模式。
设计模式六大原则
总原则：开闭原则（Open Close Principle）
开闭原则就是说 对扩展开放，对修改关闭。在程序需要扩展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。
为了使程序的扩展性好，易于维护和升级。
我们需要使用接口和抽象类等，来实现我们要的结果
1：单一职责原则（Single Responsibility Principle)）
不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。
2：里氏替换原则（Liskov Substitution Principle Lsp）
子类型必须能够替换掉他们的父类型。
Lsp是面向对象的基本原则之一。
在软件里面，把父类都替换成它的子类，程序的行为没有变化。
3：依赖倒转原则（Dependence Inversion Principle）
这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象不依赖于具体。
写代码时用到具体类时,不与具体类交互。而与具体类的上层接口交互。

4：接口隔离原则（Interface Segregation Principle）
客户端不应该依赖于它不需要的接口；一个类对另一个类的依赖应该建立在最小接口上。
要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：
单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。
5：迪米特法则（最少知道原则）（Law of Demeter ）
一个对象应该对其他对象有尽可能少的了解。
6 合成/聚合原则
合成复用原则是指尽量使用合成/聚合，而不使用继承。
合成/聚合 和继承是实现复用的两种途径
//Q:什么是合成/什么是聚合
//A:合成是特殊的聚合。合成可以比喻成 人由各个部分合成的,即人由头 四肢 躯干 等组成。合成之间的各个部分联系是非常紧密的，缺一不可
//聚合是一种单向的关系 
聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系

只有当以下的条件全部被满足时，才应当使用继承关系。

1. 子类是超类的一个特殊种类，而不是超类的一个角色，也就是区分“Has-A”和“Is-A”.只有“Is-A”关系才符合继承关系，“Has-A”关系应当使用聚合来描述。

2 .永远不会出现需要将子类换成另外一个类的子类的情况。如果不能肯定将来是否会变成另外一个子类的话，就不要使用继承。

3 .子类具有扩展超类的责任，而不是具有置换掉或注销掉超类的责任。如果一个子类需要大量的置换掉超类的行为，那么这个类就不应该是这个超类的子类。

错误的使用继承而不是合成/聚合的一个常见原因是错误地把“Has-A”当成了“Is-A”.”Is-A”代表一个类是另外一个类的一种；而“Has-A”代表一个类是另外一个类的一个角色，而不是另外一个类的特殊种类。
类与类之间主要有6种关系，他们分别是：依赖、关联、聚合、组合、继承、实现。他们的耦合度依次增强。

简单工厂模式不属于23中涉及模式，简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。
